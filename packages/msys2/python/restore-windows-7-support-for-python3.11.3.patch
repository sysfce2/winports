diff -au a/Modules/_winapi.c b/Modules/_winapi.c
--- a/Modules/_winapi.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Modules/_winapi.c	2023-05-25 00:19:57.760489600 +0200
@@ -41,6 +41,7 @@
 
 #define WINDOWS_LEAN_AND_MEAN
 #include "windows.h"
+#include <winnls.h>
 #include <crtdbg.h>
 #include "winreparse.h"
 
@@ -67,6 +68,10 @@
 static int has_CancelIoEx = -1;
 static BOOL (CALLBACK *Py_CancelIoEx)(HANDLE, LPOVERLAPPED);
 
+#if !defined(LCMAP_SORTHANDLE)
+#error "LCMAP_SORTHANDLE not defined"
+#endif
+
 static int
 check_CancelIoEx()
 {
diff -au a/Modules/getpath.c b/Modules/getpath.c
--- a/Modules/getpath.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Modules/getpath.c	2023-05-25 01:05:33.309954100 +0200
@@ -11,7 +11,7 @@
 
 #ifdef MS_WINDOWS
 #  include <windows.h>            // GetFullPathNameW(), MAX_PATH
-#  include <pathcch.h>
+#  include <Shlwapi.h>
 #endif
 
 #ifdef __APPLE__
@@ -218,6 +218,12 @@
 }
 
 
+#ifdef MS_WINDOWS
+static int _PathCchFindExtension_Initialized = 0;
+typedef HRESULT (__stdcall *PPathCchFindExtension) (PCWSTR pszPath, size_t cchPath, PCWSTR *ppszExt);
+static PPathCchFindExtension PathCchFindExtension;
+#endif
+
 static PyObject *
 getpath_isxfile(PyObject *Py_UNUSED(self), PyObject *args)
 {
@@ -228,16 +234,39 @@
     if (!PyArg_ParseTuple(args, "U", &pathobj)) {
         return NULL;
     }
+
+#ifdef MS_WINDOWS
+    if (_PathCchFindExtension_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchFindExtension = (PPathCchFindExtension)GetProcAddress(pathapi, "PathCchFindExtension");
+        } else {
+            PathCchFindExtension = NULL;
+        }
+
+        _PathCchFindExtension_Initialized = 1;
+    }
+#endif
+
     path = PyUnicode_AsWideCharString(pathobj, &cchPath);
     if (path) {
 #ifdef MS_WINDOWS
         const wchar_t *ext;
         DWORD attr = GetFileAttributesW(path);
+      if (PathCchFindExtension) {
         r = (attr != INVALID_FILE_ATTRIBUTES) &&
             !(attr & FILE_ATTRIBUTE_DIRECTORY) &&
             SUCCEEDED(PathCchFindExtension(path, cchPath + 1, &ext)) &&
             (CompareStringOrdinal(ext, -1, L".exe", -1, 1 /* ignore case */) == CSTR_EQUAL)
             ? Py_True : Py_False;
+      } else {
+        ext = PathFindExtensionW(path);
+        r = (attr != INVALID_FILE_ATTRIBUTES) &&
+            !(attr & FILE_ATTRIBUTE_DIRECTORY) &&
+            (ext != NULL) &&
+            (CompareStringOrdinal(ext, -1, L".exe", -1, 1 /* ignore case */) == CSTR_EQUAL)
+            ? Py_True : Py_False;
+      }
 #else
         struct stat st;
         r = (_Py_wstat(path, &st) == 0) &&
diff -au a/Modules/posixmodule.c b/Modules/posixmodule.c
--- a/Modules/posixmodule.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Modules/posixmodule.c	2023-05-24 18:44:29.045193000 +0200
@@ -15,7 +15,7 @@
 // whereas pycore_condvar.h defines the WIN32_LEAN_AND_MEAN macro.
 #ifdef MS_WINDOWS
 #  include <windows.h>
-#  include <pathcch.h>
+#  include <Shlwapi.h>
 #  include <lmcons.h>             // UNLEN
 #  include "osdefs.h"             // SEP
 #  define HAVE_SYMLINK
@@ -4480,6 +4480,10 @@
 Removes everything after the root on Win32.
 [clinic start generated code]*/
 
+static int _PathCchSkipRoot_Initialized = 0;
+typedef HRESULT (__stdcall *PPathCchSkipRoot) (PCWSTR pszPath, PCWSTR *ppszRootEnd);
+static PPathCchSkipRoot PathCchSkipRoot;
+
 static PyObject *
 os__path_splitroot_impl(PyObject *module, path_t *path)
 /*[clinic end generated code: output=ab7f1a88b654581c input=dc93b1d3984cffb6]*/
@@ -4498,8 +4502,25 @@
         *p = L'\\';
     }
 
+    if (_PathCchSkipRoot_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchSkipRoot = (PPathCchSkipRoot)GetProcAddress(pathapi, "PathCchSkipRoot");
+        } else {
+            PathCchSkipRoot = NULL;
+        }
+
+        _PathCchSkipRoot_Initialized = 1;
+    }
     Py_BEGIN_ALLOW_THREADS
+  if (PathCchSkipRoot) {
     ret = PathCchSkipRoot(buffer, &end);
+  } else {
+    end = PathSkipRootW(buffer);
+    if (!end) {
+        ret = E_FAIL;
+    }
+  }
     Py_END_ALLOW_THREADS
     if (FAILED(ret)) {
         result = Py_BuildValue("sO", "", path->object);
diff -au a/PC/launcher2.c b/PC/launcher2.c
--- a/PC/launcher2.c	2023-04-05 00:22:17.000000000 +0200
+++ b/PC/launcher2.c	2023-05-24 18:55:52.601290100 +0200
@@ -9,7 +9,8 @@
 #define __STDC_WANT_LIB_EXT1__ 1
 
 #include <windows.h>
-#include <pathcch.h>
+include <Shlwapi.h>
+#define PATHCCH_ALLOW_LONG_PATHS 0x00000001
 #include <fcntl.h>
 #include <io.h>
 #include <shlobj.h>
@@ -42,6 +43,14 @@
 
 static FILE * log_fp = NULL;
 
+static int _PathCchCombineEx_Initialized = 0;
+typedef HRESULT(__stdcall *PPathCchCombineEx) (PWSTR pszPathOut, size_t cchPathOut, PCWSTR pszPathIn, PCWSTR pszMore, unsigned long dwFlags);
+static PPathCchCombineEx PathCchCombineEx;
+
+static int _PathCchRemoveFileSpec_Initialized = 0;
+typedef HRESULT(__stdcall *PPathCchRemoveFileSpec) (PWSTR  pszPath, size_t cchPath);
+static PPathCchRemoveFileSpec PathCchRemoveFileSpec;
+
 void
 debug(wchar_t * format, ...)
 {
@@ -188,9 +197,25 @@
 bool
 join(wchar_t *buffer, size_t bufferLength, const wchar_t *fragment)
 {
+    if (_PathCchCombineEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+        }
+        else {
+            PathCchCombineEx = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+    }
+  if (PathCchCombineEx) {
     if (SUCCEEDED(PathCchCombineEx(buffer, bufferLength, buffer, fragment, PATHCCH_ALLOW_LONG_PATHS))) {
         return true;
     }
+  } else {
+    if (PathCombineW(buffer, buffer, fragment)) {
+        return true;
+    }
+  }
     return false;
 }
 
@@ -853,6 +878,18 @@
             winerror(0, L"Failed to read from %s\n", iniPath);
         }
     }
+
+    if (_PathCchRemoveFileSpec_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchRemoveFileSpec = (PPathCchRemoveFileSpec)GetProcAddress(pathapi, "PathCchRemoveFileSpec");
+        }
+        else {
+            PathCchRemoveFileSpec = NULL;
+        }
+        _PathCchRemoveFileSpec_Initialized = 1;
+    }
+  if (PathCchRemoveFileSpec) {
     if (GetModuleFileNameW(NULL, iniPath, MAXLEN) &&
         SUCCEEDED(PathCchRemoveFileSpec(iniPath, MAXLEN)) &&
         join(iniPath, MAXLEN, L"py.ini")) {
@@ -867,6 +904,22 @@
             winerror(0, L"Failed to read from %s\n", iniPath);
         }
     }
+  } else {
+    if (GetModuleFileNameW(NULL, iniPath, MAXLEN) &&
+        PathRemoveFileSpecW(iniPath) &&
+        join(iniPath, MAXLEN, L"py.ini")) {
+        debug(L"# Reading from %s for %s/%s\n", iniPath, section, settingName);
+        n = GetPrivateProfileStringW(section, settingName, NULL, buffer, MAXLEN, iniPath);
+        if (n) {
+            debug(L"# Found %s in %s\n", settingName, iniPath);
+            return n;
+        } else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
+            debug(L"# Did not find file %s\n", iniPath);
+        } else {
+            winerror(0, L"Failed to read from %s\n", iniPath);
+        }
+    }
+  }
     return 0;
 }
 
@@ -921,6 +974,20 @@
     }
     *pC = L'\0';
 
+    if (_PathCchCombineEx_Initialized == 0 || _PathCchRemoveFileSpec_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+            PathCchRemoveFileSpec = (PPathCchRemoveFileSpec)GetProcAddress(pathapi, "PathCchRemoveFileSpec");
+        }
+        else {
+            PathCchCombineEx = NULL;
+            PathCchRemoveFileSpec = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+        _PathCchRemoveFileSpec_Initialized = 1;
+    }
+  if (PathCchCombineEx && PathCchRemoveFileSpec) {
     if (!GetCurrentDirectoryW(MAXLEN, buffer) ||
         wcsncpy_s(script, MAXLEN, search->scriptFile, search->scriptFileLength) ||
         FAILED(PathCchCombineEx(buffer, MAXLEN, buffer, script,
@@ -931,7 +998,16 @@
     ) {
         return RC_NO_MEMORY;
     }
-
+  } else {
+    if (!GetCurrentDirectoryW(MAXLEN, buffer) ||
+        wcsncpy_s(script, MAXLEN, search->scriptFile, search->scriptFileLength) ||
+        !PathCombineExW(buffer, buffer, script) ||
+        !PathRemoveFileSpecW(buffer) ||
+        !PathCombineExW(buffer, buffer, command)
+    ) {
+        return RC_NO_MEMORY;
+    }
+  }
     int n = (int)wcsnlen(buffer, MAXLEN);
     wchar_t *path = allocSearchInfoBuffer(search, n + 1);
     if (!path) {
@@ -1419,9 +1495,25 @@
         return RC_NO_MEMORY;
     }
 
+    if (_PathCchCombineEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+        }
+        else {
+            PathCchCombineEx = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+    }
+  if (PathCchCombineEx) {
     if (FAILED(PathCchCombineEx(buffer, MAXLEN, installDir, fragmentBuffer, PATHCCH_ALLOW_LONG_PATHS))) {
         return RC_NO_MEMORY;
     }
+  } else {
+    if (!PathCombineW(buffer, installDir, fragmentBuffer)) {
+        return RC_NO_MEMORY;
+    }
+  }
 
     return copyWstr(dest, buffer);
 }
diff -au a/PC/pyconfig.h b/PC/pyconfig.h
--- a/PC/pyconfig.h	2023-04-05 00:22:17.000000000 +0200
+++ b/PC/pyconfig.h	2023-05-24 06:47:53.178970100 +0200
@@ -142,8 +142,8 @@
 
 /* set the version macros for the windows headers */
 /* Python 3.9+ requires Windows 8 or greater */
-#define Py_WINVER 0x0602 /* _WIN32_WINNT_WIN8 */
-#define Py_NTDDI NTDDI_WIN8
+#define Py_WINVER 0x0601 /* _WIN32_WINNT_WIN7 */
+#define Py_NTDDI NTDDI_WIN7
 
 /* We only set these values when building Python - we don't want to force
    these values on extensions, as that will affect the prototypes and
diff -au a/PCbuild/_freeze_module.vcxproj b/PCbuild/_freeze_module.vcxproj
--- a/PCbuild/_freeze_module.vcxproj	2023-04-05 00:22:17.000000000 +0200
+++ b/PCbuild/_freeze_module.vcxproj	2023-05-24 21:39:27.398664400 +0200
@@ -94,7 +94,7 @@
     </ClCompile>
     <Link>
       <SubSystem>Console</SubSystem>
-      <AdditionalDependencies>version.lib;ws2_32.lib;pathcch.lib;bcrypt.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>version.lib;ws2_32.lib;shlwapi.lib;bcrypt.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
     </Link>
   </ItemDefinitionGroup>
diff -au a/PCbuild/pylauncher.vcxproj b/PCbuild/pylauncher.vcxproj
--- a/PCbuild/pylauncher.vcxproj	2023-04-05 00:22:17.000000000 +0200
+++ b/PCbuild/pylauncher.vcxproj	2023-05-24 21:39:56.283316500 +0200
@@ -95,7 +95,7 @@
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>shell32.lib;pathcch.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>shell32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <SubSystem>Console</SubSystem>
     </Link>
   </ItemDefinitionGroup>
diff -au a/PCbuild/pythoncore.vcxproj b/PCbuild/pythoncore.vcxproj
--- a/PCbuild/pythoncore.vcxproj	2023-04-05 00:22:17.000000000 +0200
+++ b/PCbuild/pythoncore.vcxproj	2023-05-24 21:40:20.173683000 +0200
@@ -106,7 +106,7 @@
       <PreprocessorDefinitions Condition="$(IncludeExternals)">_Py_HAVE_ZLIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>version.lib;ws2_32.lib;pathcch.lib;bcrypt.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>version.lib;ws2_32.lib;shlwapi.lib;bcrypt.lib;%(AdditionalDependencies)</AdditionalDependencies>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
diff -au a/PCbuild/pywlauncher.vcxproj b/PCbuild/pywlauncher.vcxproj
--- a/PCbuild/pywlauncher.vcxproj	2023-04-05 00:22:17.000000000 +0200
+++ b/PCbuild/pywlauncher.vcxproj	2023-05-24 21:40:34.634510100 +0200
@@ -95,7 +95,7 @@
       <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>shell32.lib;pathcch.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>shell32.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <SubSystem>Windows</SubSystem>
     </Link>
   </ItemDefinitionGroup>
diff -au a/Python/fileutils.c b/Python/fileutils.c
--- a/Python/fileutils.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Python/fileutils.c	2023-05-24 22:36:15.967623400 +0200
@@ -8,7 +8,8 @@
 #ifdef MS_WINDOWS
 #  include <malloc.h>
 #  include <windows.h>
-#  include <pathcch.h>            // PathCchCombineEx
+#  include <Shlwapi.h>
+#define PATHCCH_ALLOW_LONG_PATHS 0x00000001
 extern int winerror_to_errno(int);
 #endif
 
@@ -2000,12 +2001,36 @@
 #endif
 
 
+#ifdef MS_WINDOWS
+static int _PathCchSkipRoot_Initialized = 0;
+typedef HRESULT (__stdcall *PPathCchSkipRoot) (PCWSTR pszPath, PCWSTR *ppszRootEnd);
+static PPathCchSkipRoot PathCchSkipRoot;
+#endif
+
 int
 _Py_isabs(const wchar_t *path)
 {
 #ifdef MS_WINDOWS
     const wchar_t *tail;
-    HRESULT hr = PathCchSkipRoot(path, &tail);
+    if (_PathCchSkipRoot_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchSkipRoot = (PPathCchSkipRoot)GetProcAddress(pathapi, "PathCchSkipRoot");
+        } else {
+            PathCchSkipRoot = NULL;
+        }
+
+        _PathCchSkipRoot_Initialized = 1;
+    }
+	HRESULT hr = 0;
+  if (PathCchSkipRoot) {
+    hr = PathCchSkipRoot(path, &tail);
+  } else {
+    tail = PathSkipRootW(path);
+    if (!tail) {
+        hr = E_FAIL;
+    }
+  }
     if (FAILED(hr) || path == tail) {
         return 0;
     }
@@ -2086,6 +2111,11 @@
 #endif
 }
 
+#ifdef MS_WINDOWS
+static int _PathCchCombineEx_Initialized = 0;
+typedef HRESULT(__stdcall *PPathCchCombineEx) (PWSTR pszPathOut, size_t cchPathOut, PCWSTR pszPathIn, PCWSTR pszMore, unsigned long dwFlags);
+static PPathCchCombineEx PathCchCombineEx;
+#endif
 
 // The caller must ensure "buffer" is big enough.
 static int
@@ -2093,10 +2123,26 @@
              const wchar_t *dirname, const wchar_t *relfile)
 {
 #ifdef MS_WINDOWS
+    if (_PathCchCombineEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+        }
+        else {
+            PathCchCombineEx = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+    }
+  if (PathCchCombineEx) {
     if (FAILED(PathCchCombineEx(buffer, bufsize, dirname, relfile,
         PATHCCH_ALLOW_LONG_PATHS))) {
         return -1;
     }
+  } else {
+    if (!PathCombineW(buffer, dirname, relfile)) {
+        return -1;
+    }
+  }
 #else
     assert(!_Py_isabs(relfile));
     size_t dirlen = wcslen(dirname);
diff -au a/Python/pathconfig.c b/Python/pathconfig.c
--- a/Python/pathconfig.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Python/pathconfig.c	2023-05-24 22:36:53.265756800 +0200
@@ -10,7 +10,6 @@
 #include <wchar.h>
 #ifdef MS_WINDOWS
 #  include <windows.h>            // GetFullPathNameW(), MAX_PATH
-#  include <pathcch.h>
 #  include <shlwapi.h>
 #endif
 

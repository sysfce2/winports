diff -au a/Modules/getpath.c b/Modules/getpath.c
--- a/Modules/getpath.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Modules/getpath.c	2023-05-24 06:34:21.621551600 +0200
@@ -11,7 +11,7 @@
 
 #ifdef MS_WINDOWS
 #  include <windows.h>            // GetFullPathNameW(), MAX_PATH
-#  include <pathcch.h>
+#  include <Shlwapi.h>
 #endif
 
 #ifdef __APPLE__
diff -au a/Modules/posixmodule.c b/Modules/posixmodule.c
--- a/Modules/posixmodule.c	2023-04-05 00:22:17.000000000 +0200
+++ b/Modules/posixmodule.c	2023-05-24 07:39:35.214396400 +0200
@@ -15,7 +15,7 @@
 // whereas pycore_condvar.h defines the WIN32_LEAN_AND_MEAN macro.
 #ifdef MS_WINDOWS
 #  include <windows.h>
-#  include <pathcch.h>
+#  include <Shlwapi.h>
 #  include <lmcons.h>             // UNLEN
 #  include "osdefs.h"             // SEP
 #  define HAVE_SYMLINK
@@ -4480,6 +4480,10 @@
 Removes everything after the root on Win32.
 [clinic start generated code]*/
 
+static int _PathCchSkipRoot_Initialized = 0;
+typedef HRESULT (__stdcall *PPathCchSkipRoot) (PCWSTR pszPath, PCWSTR *ppszRootEnd);
+static PPathCchSkipRoot _PathCchSkipRoot;
+
 static PyObject *
 os__path_splitroot_impl(PyObject *module, path_t *path)
 /*[clinic end generated code: output=ab7f1a88b654581c input=dc93b1d3984cffb6]*/
@@ -4489,6 +4493,18 @@
     PyObject *result = NULL;
     HRESULT ret;
 
+    if (_PathCchSkipRoot_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL,
+                                         LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            _PathCchSkipRoot = (PPathCchSkipRoot)GetProcAddress(pathapi, "PathCchSkipRoot");
+        } else {
+            _PathCchSkipRoot = NULL;
+        }
+
+        _PathCchSkipRoot_Initialized = 1;
+    }
+
     buffer = (wchar_t*)PyMem_Malloc(sizeof(wchar_t) * (wcslen(path->wide) + 1));
     if (!buffer) {
         return NULL;
@@ -4499,7 +4515,14 @@
     }
 
     Py_BEGIN_ALLOW_THREADS
-    ret = PathCchSkipRoot(buffer, &end);
+  if (_PathCchSkipRoot) {
+    ret = _PathCchSkipRoot(buffer, &end);
+  } else {
+    end = PathSkipRootW(buffer);
+    if (!end) {
+        ret = E_FAIL;
+    }
+  }
     Py_END_ALLOW_THREADS
     if (FAILED(ret)) {
         result = Py_BuildValue("sO", "", path->object);
diff -au a/PC/launcher2.c b/PC/launcher2.c
--- a/PC/launcher2.c	2023-04-05 00:22:17.000000000 +0200
+++ b/PC/launcher2.c	2023-05-24 06:46:18.279542100 +0200
@@ -9,7 +9,8 @@
 #define __STDC_WANT_LIB_EXT1__ 1
 
 #include <windows.h>
-#include <pathcch.h>
+include <Shlwapi.h>
+#define PATHCCH_ALLOW_LONG_PATHS 0x00000001
 #include <fcntl.h>
 #include <io.h>
 #include <shlobj.h>
@@ -42,6 +43,17 @@
 
 static FILE * log_fp = NULL;
 
+static int _PathCchCombineEx_Initialized = 0;
+typedef HRESULT(__stdcall *PPathCchCombineEx) (PWSTR pszPathOut, size_t cchPathOut,
+                                               PCWSTR pszPathIn, PCWSTR pszMore,
+                                               unsigned long dwFlags);
+static PPathCchCombineEx _PathCchCombineEx;
+
+static int _PathCchRemoveFileSpec_Initialized = 0;
+typedef HRESULT(__stdcall *PPathCchRemoveFileSpec) (PWSTR  pszPath,
+                                                    size_t cchPath);
+static PPathCchRemoveFileSpec _PathCchRemoveFileSpec;
+
 void
 debug(wchar_t * format, ...)
 {
@@ -188,9 +200,26 @@
 bool
 join(wchar_t *buffer, size_t bufferLength, const wchar_t *fragment)
 {
-    if (SUCCEEDED(PathCchCombineEx(buffer, bufferLength, buffer, fragment, PATHCCH_ALLOW_LONG_PATHS))) {
+    if (_PathCchCombineEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL,
+                                         LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            _PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+        }
+        else {
+            _PathCchCombineEx = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+    }
+  if (_PathCchCombineEx) {
+    if (SUCCEEDED(_PathCchCombineEx(buffer, bufferLength, buffer, fragment, PATHCCH_ALLOW_LONG_PATHS))) {
+        return true;
+    }
+  } else {
+    if (PathCombineW(buffer, buffer, fragment)) {
         return true;
     }
+  }
     return false;
 }
 
@@ -853,8 +882,36 @@
             winerror(0, L"Failed to read from %s\n", iniPath);
         }
     }
+
+    if (_PathCchRemoveFileSpec_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL,
+                                         LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            _PathCchRemoveFileSpec = (PPathCchRemoveFileSpec)GetProcAddress(pathapi, "PathCchRemoveFileSpec");
+        }
+        else {
+            _PathCchRemoveFileSpec = NULL;
+        }
+        _PathCchRemoveFileSpec_Initialized = 1;
+    }
+  if (_PathCchRemoveFileSpec) {
+    if (GetModuleFileNameW(NULL, iniPath, MAXLEN) &&
+        SUCCEEDED(_PathCchRemoveFileSpec(iniPath, MAXLEN)) &&
+        join(iniPath, MAXLEN, L"py.ini")) {
+        debug(L"# Reading from %s for %s/%s\n", iniPath, section, settingName);
+        n = GetPrivateProfileStringW(section, settingName, NULL, buffer, MAXLEN, iniPath);
+        if (n) {
+            debug(L"# Found %s in %s\n", settingName, iniPath);
+            return n;
+        } else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
+            debug(L"# Did not find file %s\n", iniPath);
+        } else {
+            winerror(0, L"Failed to read from %s\n", iniPath);
+        }
+    }
+  } else {
     if (GetModuleFileNameW(NULL, iniPath, MAXLEN) &&
-        SUCCEEDED(PathCchRemoveFileSpec(iniPath, MAXLEN)) &&
+        PathRemoveFileSpecW(iniPath) &&
         join(iniPath, MAXLEN, L"py.ini")) {
         debug(L"# Reading from %s for %s/%s\n", iniPath, section, settingName);
         n = GetPrivateProfileStringW(section, settingName, NULL, buffer, MAXLEN, iniPath);
@@ -867,6 +924,7 @@
             winerror(0, L"Failed to read from %s\n", iniPath);
         }
     }
+  }
     return 0;
 }
 
@@ -921,17 +979,49 @@
     }
     *pC = L'\0';
 
+    if (_PathCchCombineEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL,
+                                         LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            _PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+        }
+        else {
+            _PathCchCombineEx = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+    }
+    if (_PathCchRemoveFileSpec_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL,
+                                         LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            _PathCchRemoveFileSpec = (PPathCchRemoveFileSpec)GetProcAddress(pathapi, "PathCchRemoveFileSpec");
+        }
+        else {
+            _PathCchRemoveFileSpec = NULL;
+        }
+        _PathCchRemoveFileSpec_Initialized = 1;
+    }
+  if (_PathCchCombineEx) {
     if (!GetCurrentDirectoryW(MAXLEN, buffer) ||
         wcsncpy_s(script, MAXLEN, search->scriptFile, search->scriptFileLength) ||
-        FAILED(PathCchCombineEx(buffer, MAXLEN, buffer, script,
+        FAILED(_PathCchCombineEx(buffer, MAXLEN, buffer, script,
                                 PATHCCH_ALLOW_LONG_PATHS)) ||
-        FAILED(PathCchRemoveFileSpec(buffer, MAXLEN)) ||
-        FAILED(PathCchCombineEx(buffer, MAXLEN, buffer, command,
+        FAILED(_PathCchRemoveFileSpec(buffer, MAXLEN)) ||
+        FAILED(_PathCchCombineEx(buffer, MAXLEN, buffer, command,
                                 PATHCCH_ALLOW_LONG_PATHS))
     ) {
         return RC_NO_MEMORY;
     }
-
+  } else {
+    if (!GetCurrentDirectoryW(MAXLEN, buffer) ||
+        wcsncpy_s(script, MAXLEN, search->scriptFile, search->scriptFileLength) ||
+        !PathCombineExW(buffer, buffer, script) ||
+        !PathRemoveFileSpecW(buffer) ||
+        !PathCombineExW(buffer, buffer, command)
+    ) {
+        return RC_NO_MEMORY;
+    }
+  }
     int n = (int)wcsnlen(buffer, MAXLEN);
     wchar_t *path = allocSearchInfoBuffer(search, n + 1);
     if (!path) {
@@ -1419,9 +1509,26 @@
         return RC_NO_MEMORY;
     }
 
-    if (FAILED(PathCchCombineEx(buffer, MAXLEN, installDir, fragmentBuffer, PATHCCH_ALLOW_LONG_PATHS))) {
+    if (_PathCchCombineEx_Initialized == 0) {
+        HMODULE pathapi = LoadLibraryExW(L"api-ms-win-core-path-l1-1-0.dll", NULL,
+                                         LOAD_LIBRARY_SEARCH_SYSTEM32);
+        if (pathapi) {
+            _PathCchCombineEx = (PPathCchCombineEx)GetProcAddress(pathapi, "PathCchCombineEx");
+        }
+        else {
+            _PathCchCombineEx = NULL;
+        }
+        _PathCchCombineEx_Initialized = 1;
+    }
+  if (_PathCchCombineEx) {
+    if (FAILED(_PathCchCombineEx(buffer, MAXLEN, installDir, fragmentBuffer, PATHCCH_ALLOW_LONG_PATHS))) {
+        return RC_NO_MEMORY;
+    }
+  } else {
+    if (!PathCombineW(buffer, installDir, fragmentBuffer)) {
         return RC_NO_MEMORY;
     }
+  }
 
     return copyWstr(dest, buffer);
 }
diff -au a/PC/pyconfig.h b/PC/pyconfig.h
--- a/PC/pyconfig.h	2023-04-05 00:22:17.000000000 +0200
+++ b/PC/pyconfig.h	2023-05-24 06:47:53.178970100 +0200
@@ -142,8 +142,8 @@
 
 /* set the version macros for the windows headers */
 /* Python 3.9+ requires Windows 8 or greater */
-#define Py_WINVER 0x0602 /* _WIN32_WINNT_WIN8 */
-#define Py_NTDDI NTDDI_WIN8
+#define Py_WINVER 0x0601 /* _WIN32_WINNT_WIN7 */
+#define Py_NTDDI NTDDI_WIN7
 
 /* We only set these values when building Python - we don't want to force
    these values on extensions, as that will affect the prototypes and
diff -au a/PCbuild/pythoncore.vcxproj b/PCbuild/pythoncore.vcxproj
--- a/PCbuild/pythoncore.vcxproj	2023-04-05 00:22:17.000000000 +0200
+++ b/PCbuild/pythoncore.vcxproj	2023-05-24 07:48:24.834688900 +0200
@@ -106,7 +106,7 @@
       <PreprocessorDefinitions Condition="$(IncludeExternals)">_Py_HAVE_ZLIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>version.lib;ws2_32.lib;pathcch.lib;bcrypt.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>version.lib;shlwapi.lib;ws2_32.lib;bcrypt.lib;%(AdditionalDependencies)</AdditionalDependencies>
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
